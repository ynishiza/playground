ROLLBACK;
BEGIN;

DROP TABLE IF EXISTS test_partitioned, test_partitioned_1, test_partitioned_2, test_partitioned_2_1, test_partitioned_rest;

-- Step 1) Initial setup
CREATE TEMPORARY TABLE test_partitioned (
  id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  value VARCHAR NOT NULL DEFAULT '',
  x INT NOT NULL DEFAULT 1 CHECK (x > 0),
  x2 INT NOT NULL GENERATED ALWAYS AS (x * 2) STORED,
  UNIQUE(id, value)
)
PARTITION BY RANGE (id);

CREATE INDEX on test_partitioned (value);

-- Create initial partitions
CREATE TEMPORARY TABLE test_partitioned_1 PARTITION OF test_partitioned
  FOR VALUES FROM (0) TO (1000);
CREATE TEMPORARY TABLE test_partitioned_rest PARTITION OF test_partitioned DEFAULT;
INSERT INTO test_partitioned (value)
  (SELECT format('value%s', x * x) FROM generate_series(1, 10000) AS t(x));

\prompt 'Split partition' x
-- Step 2) insert another partition by CREATE TABLE ... PARTITION OF ...
ALTER TABLE test_partitioned DETACH PARTITION test_partitioned_rest;
CREATE TEMPORARY TABLE test_partitioned_2 PARTITION OF test_partitioned
  FOR VALUES FROM (1000) to (2000);

\set columns 'id, created, value, x'
INSERT INTO test_partitioned (SELECT :columns FROM test_partitioned_rest WHERE id < 2000);
DELETE FROM test_partitioned_rest WHERE id < 2000;

-- Step 3) insert another partition by CREATE TABLE + LIKE
\prompt 'Split partition using LIKE' x
CREATE TEMPORARY TABLE test_partitioned_2_1 (
  LIKE test_partitioned
  INCLUDING GENERATED
  INCLUDING CONSTRAINTS
);

\prompt 'Original table' _
\d test_partitioned_2_1
-- NOTE: cannot have IDENTITY on partitioned value
-- Uses the parent table's instead
-- ALTER TABLE test_partitioned_2_1 ALTER COLUMN id DROP IDENTITY;

-- ALTER TABLE test_partitioned_2_1 ALTER COLUMN x ADD GENERATED BY DEFAULT AS IDENTITY;

INSERT INTO test_partitioned_2_1 (SELECT :columns FROM test_partitioned_2 WHERE id >= 1500);
DELETE FROM test_partitioned_2 WHERE id >= 1500;

ALTER TABLE test_partitioned_2_1 ADD CONSTRAINT temp_check CHECK(id >= 1500 AND id < 2000);
ALTER TABLE test_partitioned_rest ADD CONSTRAINT temp_check2 CHECK(id >= 2000);
ALTER TABLE test_partitioned DETACH PARTITION test_partitioned_2;
ALTER TABLE test_partitioned ATTACH PARTITION test_partitioned_2 FOR VALUES FROM (1000) to (1500);
ALTER TABLE test_partitioned ATTACH PARTITION test_partitioned_2_1 FOR VALUES FROM (1500) to (2000);
ALTER TABLE test_partitioned_2_1 DROP CONSTRAINT temp_check;
ALTER TABLE test_partitioned_rest DROP CONSTRAINT temp_check2;
\d test_partitioned_2_1
\prompt 'Attached table' _


-- Step 4) Change DEFAULT to MAXVALUE
ALTER TABLE test_partitioned ATTACH PARTITION test_partitioned_rest DEFAULT;
ALTER TABLE test_partitioned DETACH PARTITION test_partitioned_rest;
ALTER TABLE test_partitioned ATTACH PARTITION test_partitioned_rest FOR VALUES FROM (2000) TO (MAXVALUE);

-- SELECT min(value), max(value) FROM test_partitioned_0_5;
SELECT min(value), max(value) FROM test_partitioned_1;
SELECT min(value), max(value) FROM test_partitioned_2;
SELECT min(value), max(value) FROM test_partitioned_rest;

\prompt 'Sample:' x
select * FROM test_partitioned TABLESAMPLE BERNOULLI(1) ;
COMMIT;

-- What happens if not default?
-- ALTER TABLE test_partitioned_rest ALTER COLUMN value DROP DEFAULT;
-- INSERT INTO test_partitioned (id, value) VALUES (1000000012, DEFAULT);
-- INSERT INTO test_partitioned_rest (id, value) VALUES (1000000013, DEFAULT);
